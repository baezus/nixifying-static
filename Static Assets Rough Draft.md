# Nixifying Static Assets in Obelisk

###### Dek: Using a Nix expression to deliver static assets to a page powered by Obelisk.

How we enabled the use of custom nix expressions to serve static assets generated by Tailwind and PostCSS to an Obelisk application.

#### Context:

Obelisk is our framework for building full stack applications across platforms. Obelisk projects often utilise static assets of varying kinds, be they images and other media or the CSS necessary to style the HTML. These are the stable images and other media that we expect displayed when we visit a webpage. Also considered static assets are the CSS stylesheets used to customize HTML elements.

Raw CSS files are not written as frequently as compiled-to-CSS stylesheets, which would have originally been written in another language that compiles to CSS, like Sass, Tailwind, or PostCSS. While these meta-CSS frameworks offer efficiency, consistency, and other benefits, the tradeoff is that assets produced by those methods must be compiled before they're usable by the frontend. 

To incorporate Tailwind and PostCSS into our frontend development workflow, we had to teach an Obelisk application how to compile these assets. There were a few considerations that we kept in mind:

- **Safety**
  
  - Where possible, we lean on the capabilities of Haskell and Nix that let us catch errors and failures at build time, rather than run time. In the context of asset handling we want to make sure developers encounter errors during development, rather than users seeing wonky styling or missing images.

- **Speed**
  
  - We often work with content-addressed data and hashed assets in Nix, and here we wanted no different. If an asset doesn't change, then the hash doesn't change. Therefore, we can cache an unchanged asset, and only ever seek to re-build or re-compile it when there has been a change. This improves speed and security.

- **Uptime**
  
  - We built a way to refer to assets without using hashes, but in such a way that the hash data is not lost when assets move into the production environment. 

- **Updates**
  
  - Finally, we want to support workflows where users can modify static assets while developing their application, in such a way where the new assets are available immediately and automatically by someone running `ob run`.

This post will explain our solution to these needs, vis-a-vis Tailwind and PostCSS. It will be based upon, and explicitly use code examples from, the [Obelisk repository guide](https://github.com/obsidiansystems/obelisk-tailwind-example) regarding this process.

#### Content:

Follow that guide until you've created the `styles.css` file, then come back here.

Beginning of the Nixify section. What does that mean, and why do we wanna do it?

```#!
cd static/src
nix-shell -p nodePackages.node2nix --run node2nix
```

vii. Write a Nix derivation about how to store the assets, and source them to a currently running Obelisk site.  

```nix
(import (builtins.fetchTarball {
   name = "nixpkgs-unstable_2020-11-18";
   url = "https://github.com/nixos/nixpkgs/archive/4f3475b113c93d204992838aecafa89b1b3ccfde.tar.gz";
   sha256 = "158iik656ds6i6pc672w54cnph4d44d0a218dkq6npzrbhd3vvbg";
 }) {}).nodePackages.node2nix
```

Use node2nix by running:

```#!
$(nix-build node2nix.nix)/bin/node2nix
```

in `static/default.nix`:

```nix
{ pkgs }:
let
  # The nixified node project was generated from a package.json file in src using node2nix
  # See https://github.com/svanderburg/node2nix#using-the-nodejs-environment-in-other-nix-derivations
  nodePkgs = (pkgs.callPackage ./src {}).shell.nodeDependencies;

  # The frontend source files have to be passed in so that tailwind's purge option works
  # See https://tailwindcss.com/docs/optimizing-for-production#removing-unused-css
  frontendSrcFiles = ../frontend;

in pkgs.stdenv.mkDerivation {
  name = "static";
  src = ./src;
  buildInputs = [pkgs.nodejs];
  installPhase = ''
    mkdir -p $out/css
    mkdir -p $out/images

    # Setting up the node environment:
    ln -s ${nodePkgs}/lib/node_modules ./node_modules
    export PATH="${nodePkgs}/bin:$PATH"

    # We make the frontend haskell source files available here:
    # This corresponds to the path specified in tailwind.config.js
    ln -s ${frontendSrcFiles} frontend

    # Run the postcss compiler:
    postcss css/styles.css -o $out/styles.css

    # We can write other commands to produce more static files as well:
    cp -r images/* $out/images/
  '';
}
```

viii. In your project's `default.nix` file, tell Obelisk to use the static files derivation.  

```nix
{ system ? builtins.currentSystem
, obelisk ? import ./.obelisk/impl {
    inherit system;
    iosSdkVersion = "13.2";
  }
}:
with obelisk;
project ./. ({ pkgs, ... }: {
  staticFiles = import ./static { inherit pkgs; };
  android.applicationId = "systems.obsidian.obelisk.examples.tailwind";
  android.displayName = "Obelisk + Tailwind CSS";
  ios.bundleIdentifier = "systems.obsidian.obelisk.examples.tailwind";
  ios.bundleName = "Obelisk + Tailwind CSS";
})
```

ix. ob run functions a bit like Nodemon.  

Outcome:  
i. profit
